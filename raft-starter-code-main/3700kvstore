#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

#heads up, may refactor all the names of these methods to the names within the actual RAFT document, idk tho
BROADCAST = "FFFF"
states = ["FOLLOWER", "CANDIDATE", "LEADER"]
kvstore = {}

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        #upon startup all replicas should be followers
        self.state = states[0]
        self.term = 0
        self.transactionlog = []
        self.votedFor = None
        self.currentLeader = BROADCAST
        self.votes = 0
        self.lastTerm = 0
        self.committed = 0
        #strictly used by the leader, and is used for determining for each replica what is the next entry to be commited.
        #starts at the index of the new leaders log
        self.nextIndex = {}
        #dictionary for each replica to determine how much they have acknowledged
        self.matchIndex = {}
        #array for when the leader is unknown, and a follower recieves get/put requests, it'll store it in here.
        self.msgqueue = []
        #clock for determining when we haven't recieved messages from the leader.
        self.msgtimer = time.time()
        self.timeout = random.uniform(.3, .5)

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        #just sends the initial start message to the other replicas, 
        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def run(self):
        while True:
            socket = [self.socket]
            if(self.state == "FOLLOWER" or self.state == "CANDIDATE"):
                socks = select.select(socket, [], [], self.timeout)[0]
                #timer for determining when we haven't heard from the leader in a while.
                v = time.time() - self.msgtimer
                if(v > self.timeout):
                    self.resettimer()
                    self.electionProcess()
   
                for conn in socks:
                    data, addr = conn.recvfrom(65535)
                    msg = data.decode('utf-8')
                    self.processRequest(msg)

            else:
                currenttime = time.time()
                socks = select.select(socket, [], [], 0.1)[0]
                latertime = time.time()

                if(latertime - currenttime > 0.1):
                    for replica in self.others:
                        Heartbeat = {"src": self.id, "dst": replica , "leader": self.id, "type": "update", "commitlength": self.committed, "term": self.term}
                        self.send(Heartbeat)
   
                for conn in socks:
                    data, addr = conn.recvfrom(65535)
                    msg = data.decode('utf-8')
                    self.processRequest(msg)

    #Method for processing and then delivering any incoming request to its correct function
    def processRequest(self, msg):
        msg = json.loads(msg)

        if(msg["type"] == "put"):
            self.doPutRequest(msg)
        if(msg["type"] == "get"):
            self.doGetRequest(msg)
        if(msg['type'] == "voting"):
            self.voteLeader(msg)
        if(msg['type'] == "vote"):
            self.resettimer()
            self.processVote(msg)
            if(self.votes >= 3):
                #clear total amount of votes recieved and shift into leader state
                self.votes = 0
                self.state = states[2]
                for replica in self.others:
                    #for each replica send out the intial update/heartbeat messages to establish a new leader.
                    print("NEW LEADER: " + self.id)
                    newLeaderMessage = {"src": self.id, "dst": replica , "leader": self.id, "type": "update", "term": self.term, "commitlength": self.committed}
                    self.currentLeader = self.id
                    self.nextIndex[replica] = len(self.transactionlog)
                    self.matchIndex[replica] = 0
                    self.send(newLeaderMessage)

                #also if newley elected leader, handle potential redirects stored when we did not know the leader.    
                self.sendredirects()    

        if(msg['type'] == "update"):
            #whenever we recieve an update message from the leader, reset our timer since we know they're alive.
            self.resettimer()
            if(msg['term'] < self.term):
                #if our term is greater than the leaders, we give them a false to make them step down from leadership
                self.send({"src": self.id, "dst": msg['src'],  "leader": self.currentLeader, "type" : "response", "success" : "false", "term": self.term})

            else:
                #else if terms are the same, we simply accept the leader message, and forward any redirects within our queue
                self.currentLeader = msg["leader"]
                self.sendredirects()  
 
        if(msg['type'] == "response"):
            self.determineResponse(msg)

        if(msg['type'] == 'appendEntry'):
            self.processAppendEntry(msg)

    #Method for forwarding all redirects within the message queue to our current leader once we know it.       
    def sendredirects(self):
        if(self.state == states[2]):
            if(len(self.msgqueue) > 0):
                for i in self.msgqueue:
                    msgfrom = i['src']
                    mid = i['MID']
                    redirectmessage = {"src": self.id, "dst": msgfrom,  "leader": self.id, "type": "redirect", "MID": mid}
                    self.send(redirectmessage)
                    self.msgqueue.remove(i)
        else:
            if(self.currentLeader != 'FFFF'):
                if(len(self.msgqueue) > 0):
                    for i in self.msgqueue:
                        msgfrom = i['src']
                        mid = i['MID']
                        redirectmessage = {"src": self.id, "dst": msgfrom,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
                        self.send(redirectmessage)
                        self.msgqueue.remove(i) 

    #Method to reset our election timer
    def resettimer(self):
        self.msgtimer = time.time()
        self.timeout = random.uniform(.3,.5)

    #Handles put requests from the client
    def doPutRequest(self, msg):
        hdst = msg['src']
        mid = msg['MID']
        
        if(self.state == states[0] or self.state == states[1]):
            self.msgqueue.append(msg)

        else:
            location = (msg['key'], msg['value'], hdst, mid)
            logentry = (location, self.term)
            self.transactionlog.append(logentry)
            self.matchIndex[self.id] = len(self.transactionlog)

            #send to replicas, and wait for their response
            for replica in self.others:
                newlog = self.createEntries(replica)

                AppendMessage = {"src": self.id, "dst": replica,  "leader": self.currentLeader, "type": "appendEntry", "commitlength": self.committed, "entries": newlog, "term": self.term ,"kvstorelen" : len(kvstore)}

                if(self.nextIndex[replica] == 0):
                    AppendMessage['lastIndex'] = 0
                    self.send(AppendMessage)
                else:
                    nextIndex = self.nextIndex[replica]
                    term = self.transactionlog[nextIndex - 1][1]
                    AppendMessage['lastIndex'] = nextIndex
                    AppendMessage['lastTerm'] = term
                    self.send(AppendMessage)

    #creates the entries for a given follower based on the leaders transaction log and the followers nextIndex
    def createEntries(self, replica):
        rloglength = self.nextIndex[replica]
        #if the distance between the replica and the follower is over 80 it is likely that they have died and are not coming back, and we do not
        #append more messages otherwise we will crash our JSON when we send it.
        if(len(self.transactionlog) - rloglength > 80):
            return []
        else:
            entries = self.transactionlog[rloglength::]
            return entries 

    #method for a follower: recieves append entries from the leader, and determines whether it can append to its log given raft safety measures
    #if it cannot it passes back a false reply for the leader to then handle it.
    def processAppendEntry(self, msg):
        lterm = msg["term"]

        failMsg = {"src": self.id, "dst": msg['src'],  "leader": self.currentLeader, "type" : "response", "success" : "false", "term": self.term}
        if(lterm >= self.term):
            self.votedFor = None
            self.state = states[0]
            self.term = lterm
            self.resettimer()

            explog = msg['lastIndex']
            logentry = msg['entries']
            if(len(self.transactionlog) >= explog):
                if(explog == 0):
                    self.removebadEntries(logentry, explog)
                    CorrectMsg = {"src": self.id, "dst": self.currentLeader,  "leader": self.currentLeader, "type" : "response", "success" : "true", "loglength" : len(self.transactionlog), "term": self.term}
                    self.commitEntriesReplica(msg['commitlength'])
                    self.send(CorrectMsg)

                elif(self.transactionlog[explog - 1][1] == msg['lastTerm']):
                    self.removebadEntries(logentry, explog)
                    self.commitEntriesReplica(msg['commitlength'])
                    CorrectMsg = {"src": self.id, "dst": self.currentLeader,  "leader": self.currentLeader, "type" : "response", "success" : "true", "loglength" : len(self.transactionlog), "term": self.term}
                    self.send(CorrectMsg)
                else:
                    self.send(failMsg)
            else:
                self.send(failMsg)
        else:
            self.send(failMsg)         

    #For a replica: commits the entries based on the leaders commit index
    def commitEntriesReplica(self, commitlength):
        count = 0
        while(self.committed < commitlength):
            self.committed +=1
            key = self.transactionlog[self.committed -1][0][0]
            value = self.transactionlog[self.committed -1][0][1]
            kvstore[key] = value

            count += 1  

    #Method for a replica to append onto its transaction log from the leader, first it determines whether we have stale entries
    #then after we remove those stale entries we commit only the necessary entries from the log.
    def removebadEntries(self, logentry, explog):
        currentlog = len(self.transactionlog)
        if(currentlog > explog):
            #last comparable log index they share
            lastlogindex =  min(currentlog, len(logentry) + explog) - 1
            #does this make sense?
            logdifference = (lastlogindex - (explog - 1)) - 1
            if(self.transactionlog[lastlogindex][1] != logentry[logdifference][1]):
                newlog = self.transactionlog[:explog]
                self.transactionlog = newlog

        meaningfulentries = len(self.transactionlog) - explog

        entries = logentry[meaningfulentries::]
        self.transactionlog.extend(entries)

    #Method for a leader: after revieving an appendEntry response from the follower determines whether we can update their
    #nextIndex and matchIndex , if the message failed decreases the index by 1 and sends the next entry again
    def determineResponse(self, msg):
        if(self.state == states[2]):
            term = msg["term"]
            if(term > self.term):
                self.state = states[0]
                self.term = term
                self.votedFor = None
                self.currentLeader = BROADCAST

            else:
                if(msg['success'] == "true"):
                    fmatchIndex = msg['loglength']
                    follower = msg['src']
                    self.matchIndex[follower] = fmatchIndex
                    self.nextIndex[follower] = fmatchIndex
                    self.determineCommitted(msg)
                
                else:
                    src = msg["src"]
                    item = self.nextIndex[src]
                    self.nextIndex[src] = item - 1

                    newentries = self.createEntries(src)
                    
                    newterm = self.transactionlog[self.nextIndex[src]][1]                    
                    newmsg = {"src": self.id, "dst": src,  "leader": self.currentLeader, "type": "appendEntry", "commitlength": self.committed, "entries": newentries, "lastIndex" : self.nextIndex[src], "lastTerm" : newterm, "term": self.term }
                    self.send(newmsg)

    #While loop for the leader to go through the response lens of each of the replicas and determines whether an entry has reached quorum
    #and is able to be committed.
    def determineCommitted(self, msg):
        while(self.committed < len(self.transactionlog)):
            totalcommitted = 0
            for k, v in self.matchIndex.items():
                if(v > self.committed and v > 0):
                    totalcommitted += 1

            if(totalcommitted >= 3):
                self.committed +=1
                key = self.transactionlog[self.committed -1][0][0]
                value = self.transactionlog[self.committed -1][0][1]
                kvstore[key] = value

                src = value = self.transactionlog[self.committed - 1][0][2]
                mid = self.transactionlog[self.committed - 1][0][3]

                okmessage = {"src": self.id, "dst": src,  "leader": self.currentLeader, "type": "ok", "MID": mid}
                self.send(okmessage)

            else:
                #if there is no new entry that has reached quorum we just exit the loop
                break    


    #Method for handling the get requests from the client.            
    def doGetRequest(self,msg):
        hdst = msg['src']
        mid = msg['MID']
        leader = msg["leader"]

        #probably can change this as well
        if(self.state == states[0] or self.state == states[1]):
            if(leader != self.currentLeader):
                if(self.currentLeader == 'FFFF'):
                    self.msgqueue.append(msg)
                else:
                    redirectmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
                    self.send(redirectmessage)

        else:
            try:
                key = msg['key']
                value = kvstore[key]
                okmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "ok", "MID": mid, "value": value}
                self.send(okmessage)

            except:
                notokmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "ok", "MID": mid, "value": []}
                self.send(notokmessage)    

    
    def electionProcess(self):
        self.votes = 0
        newterm = self.term + 1
        self.term = newterm
        self.state = states[1]

        #for each replica relay the message and the new term number, and tell themt that we want to request a vote for a leader.
        RequestVote = {"src": self.id, "dst": None, "leader": self.currentLeader, "type": "voting", "newterm": newterm, "votedfor" : self.id, "lastIndex": len(self.transactionlog)}
        if(len(self.transactionlog) > 0):
            RequestVote["lastTerm"] = self.transactionlog[-1][1]

        for replica in self.others:
            RequestVote["dst"] = replica
            self.send(RequestVote) 
            #doing this in this loop seems sus...  
            self.votedFor = self.id
            self.votes = 1
            #if we vote for ourselves, then we have a vote

    #make sure to reset voted for after sometime.        
    def voteLeader(self, msg):
        #how to make sure not to vote multiple times, we immediately take their term,
        # so another vote at the same time would have a lower term value and we would immediately deny their request
        term  = msg['newterm']
        BadVote = {"src": self.id, "dst": msg["src"], "leader": self.currentLeader, "type": "vote", "voted?": "false"}
        GoodVote = {"src": self.id, "dst": msg["src"], "leader": self.currentLeader, "type": "vote", "voted?": "true"}

       #if we have already voted for someone, i.e we took their term, then someone coming in for the same term wouldn't get
       # a response 
        if(term > self.term):
            self.state = states[0]
            self.term = term
            self.votedFor = None
            self.resettimer()

            candidatelength = msg["lastIndex"]
            if(candidatelength == 0):
                if(len(self.transactionlog) == candidatelength and self.votedFor == None):
                    self.votedFor = msg['src']
                    GoodVote["term"] = self.term
                    self.send(GoodVote)
                else:
                    BadVote["term"] = self.term
                    self.send(BadVote)    
            else:
                #not exactly like the video so we'll see if this works.
                if(len(self.transactionlog) <= candidatelength):
                    #if their log is at least the length of our log
                    #if their term at that last entry is at least as good as ours, send out a vote.
                    ourlastTerm = self.transactionlog[-1][1]
                    if(msg['lastTerm'] >= ourlastTerm and self.votedFor == None):
                    #if(self.transactionlog[candidatelength -1][1] >= msg['lastTerm'] and self.votedFor == None):
                        self.votedFor = msg['src']
                        GoodVote["term"] = self.term
                        self.send(GoodVote)
                    else:
                        BadVote["term"] = self.term
                        self.send(BadVote)
                else:
                    BadVote["term"] = self.term
                    self.send(BadVote)

        else:
            BadVote["term"] = self.term
            self.send(BadVote)

    #Method for candidate: processes the responses from the replicas voting
    def processVote(self, msg):
        #just quick error handling for when a message may fail and someone has a greater term it transitions back into follower
        self.resettimer()
        term = msg["term"]
        if(term > self.term):
            self.state = states[0]
            self.term = term
            self.votedFor = None
            self.votes = 0

        else:
            #else the term must be the same, otherwise it would not have voted.
            if(msg['voted?'] == "true"):
                self.votes += 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
