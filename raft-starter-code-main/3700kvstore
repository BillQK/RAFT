#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
#not sure if states can be openly strings, 
states = ["FOLLOWER", "CANDIDATE", "LEADER"]
statemachine = {}

class ReplicaStateModel:
    def __intit__(self):
        self.state = "FOLLOWER"
        self.term = 0
        self.log = []

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        #upon startup all replicas should be followers
        self.state = states[0]
        self.term = 0
        self.transactionlog = []
        self.votedFor = None
        self.currentLeader = BROADCAST
        self.votes = 0
        self.lastTerm = 0
        self.committed = 0
        #strictly used by the leader, and is used for determining for each replica what is the next entry to be commited.
        #starts at the index of the new leaders log
        self.nextIndex = {}
        #dictionary for each replica to determine how much they have acknowledged
        self.responselen = {}
        self.leadercount = 0
        #array for when the leader is unknown, and we recieve get/put requests.
        self.msgqueue = []
        self.msgsent = 0
        self.msgtimer = time.time()
        self.timeout = random.uniform(.3, .5)

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        #just sends the initial start message to the other replicas, 
        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def run(self):
        while True:
            socket = [self.socket]
            if(self.state == "FOLLOWER" or self.state == "CANDIDATE"):
                #currenttime = time.time()
                #randomizedtime = random.uniform(.3, .5)
                socks = select.select(socket, [], [], self.timeout)[0]
                #having a timeer on select is weird, idk how it worked last time,
                # but now random leader crashes just clog the socket so it won't time out...
                #latertime = time.time()
                
                #if we have not heard anything within the time, then we have timed out, and there needs to be a new election 
                #anything that we care about for the candidate/follower i.e a message from a leader, not put request,
                v = time.time() - self.msgtimer
                if(v > self.timeout):
                    #only happens when the simulator doesn't know who the leader is...
                    #self.currentLeader = self.id
                    #print("Heading into candidate state!")
                    print("Replica: " + self.id + " timed out now starting an election.")
                    print("it's initial time is: " + str(self.msgtimer) + " and its's timeout is: " + str(self.timeout))
                    self.resettimer()
                    self.electionProcess()

                #else we should recieve on the socket like normal    
                for conn in socks:
                    data, addr = conn.recvfrom(65535)
                    msg = data.decode('utf-8')
                    #print("Received message '%s'" % (msg,), flush=True)
                    self.processRequest(msg)

            else:
                currenttime = time.time()
                socks = select.select(socket, [], [], 0.1)[0]
                latertime = time.time()

                if(latertime - currenttime > 0.1):
                    for replica in self.others:
                        Heartbeat = {"src": self.id, "dst": replica , "leader": self.id, "type": "update", "commitlength": self.committed, "term": self.term}
                        #self.leadercount += 1
                        self.send(Heartbeat)
   
                for conn in socks:
                    data, addr = conn.recvfrom(65535)
                    msg = data.decode('utf-8')
                    #print("Received message '%s'" % (msg,), flush=True)
                    self.processRequest(msg)


    def processRequest(self, msg):
        msg = json.loads(msg)

        if(msg["type"] == "put"):
            #print("Received message '%s'" % (msg,), flush=True)
            self.doPutRequest(msg)
        if(msg["type"] == "get"):
            #print("Received message '%s'" % (msg,), flush=True)
            self.doGetRequest(msg)
        if(msg['type'] == "voting"):
            print("Received message '%s'" % (msg,), flush=True)
            self.voteLeader(msg)
        if(msg['type'] == "vote"):
            self.resettimer()
            print("Received message '%s'" % (msg,), flush=True)
            #for some reason terms jump up by two now,
            #if you are in candidate state you should add to it, i guess?, it just sends out one more update message.
            self.processVote(msg)
            if(self.votes >= 3):
                #clear out the amount of votes we recieved.
                self.votes = 0
                self.state = states[2]
                #for now does this election twice, will see how often it does it.
                for replica in self.others:
                    print("NEW LEADER: " + self.id)
                    newLeaderMessage = {"src": self.id, "dst": replica , "leader": self.id, "type": "update", "term": self.term, "commitlength": self.committed}
                    self.currentLeader = self.id
                    self.nextIndex[replica] = len(self.transactionlog)
                    self.responselen[replica] = 0
                    self.send(newLeaderMessage)

                self.sendredirects()    

        if(msg['type'] == "update"):
            self.resettimer()
            if(msg['term'] < self.term):
                self.send({"src": self.id, "dst": msg['src'],  "leader": self.currentLeader, "type" : "response", "success" : "false", "term": self.term})

            else:
                self.currentLeader = msg["leader"]
                self.sendredirects()  

        #leader should only have access to appendrpc responses.    
        if(msg['type'] == "response"):
            print("Received message '%s'" % (msg,), flush=True)
            self.determineResponse(msg)

        if(msg['type'] == 'appendEntry'):
            #self.resettimer()
            #print("Received message '%s'" % (msg,), flush=True)
            self.processAppendEntry(msg)

    #replica outright died, why didn't it hold a new election?        
    def sendredirects(self):
        if(self.state == states[2]):
            if(len(self.msgqueue) > 0):
                #if this still breaks, could just use a while loop to make my life easier and just pop an item off one at a time.
                #keys are still the same, so I assume that for some reason this loop doesn't exit once it hits the leader.
                for i in self.msgqueue:
                    msgfrom = i['src']
                    mid = i['MID']
                    redirectmessage = {"src": self.id, "dst": msgfrom,  "leader": self.id, "type": "redirect", "MID": mid}
                    self.send(redirectmessage)
                    self.msgqueue.remove(i)
        else:
            if(self.currentLeader != 'FFFF'):
                if(len(self.msgqueue) > 0):
                    for i in self.msgqueue:
                        msgfrom = i['src']
                        mid = i['MID']
                        redirectmessage = {"src": self.id, "dst": msgfrom,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
                        self.send(redirectmessage)
                        self.msgqueue.remove(i)
            else:
                print("made it here!, why are we still redirecting?")    

    def resettimer(self):
        self.msgtimer = time.time()
        self.timeout = random.uniform(.3,.5)


    def doPutRequest(self, msg):
        hdst = msg['src']
        mid = msg['MID']
        leader = msg["leader"]
        #print("Our current leader is :" + self.currentLeader)
        
        if(self.state == states[0] or self.state == states[1]):
            self.msgqueue.append(msg)


            #if the leader coming in is not what we expect, then redirect them with the correct leader
        #    if(leader != self.currentLeader):
        #        #if the leader is unkown then queue, and once we get the append entries from one we deem to be a leader, send
        #        if(self.currentLeader == 'FFFF'):
        #            self.msgqueue.append(msg)
        #        else:
        #            redirectmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
        #            self.send(redirectmessage)
        #            print("made it to this case for some reason!1")
        #    else:
        #        if(self.currentLeader == 'FFFF'):
        #            self.msgqueue.append(msg)
        #        else:
        #        #else the leader is correct, but somehow it still managed to reach this replica, so we still forward.
        #            redirectmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
        #            self.send(redirectmessage)
        #            print("made it to this case for some reason!2")
        
        else:
        #if(leader == self.currentLeader):
        #either way methods still apply...
            print("LEADER RECIEVED MSG: " + mid + msg['key'])
            location = (msg['key'], msg['value'], hdst, mid)
            logentry = (location, self.term)
            self.transactionlog.append(logentry)
            self.leadercount += 1
            #basically saying that we have recieved this message and appended to our log
            self.responselen[self.id] = len(self.transactionlog)

            #send to replicas, and wait for their response
            for replica in self.others:
                newlog = self.createEntries(replica)

                AppendMessage = {"src": self.id, "dst": replica,  "leader": self.currentLeader, "type": "appendEntry", "commitlength": self.committed, "entries": newlog, "term": self.term ,"statemachinelen" : len(statemachine)}

                if(self.nextIndex[replica] == 0):
                    AppendMessage['lastIndex'] = 0
                    self.send(AppendMessage)
                else:
                    nextIndex = self.nextIndex[replica]
                    term = self.transactionlog[nextIndex - 1][1]
                    AppendMessage['lastIndex'] = nextIndex
                    AppendMessage['lastTerm'] = term
                    self.send(AppendMessage)


    def createEntries(self, replica):
        #what we suspect the replicas log to be at
        #this is wrong it sends the first part of the log not the last half, thats why when new entries comes in, it sends the wrong stuff...
        rloglength = self.nextIndex[replica]
        if(len(self.transactionlog) - rloglength > 80):
            print("you must have died, not sending amymore messages")
            return []
        else:
            entries = self.transactionlog[rloglength::]
            return entries 

    #method for a follower:
    def processAppendEntry(self, msg):
        lterm = msg["term"]

        failMsg = {"src": self.id, "dst": msg['src'],  "leader": self.currentLeader, "type" : "response", "success" : "false", "term": self.term}
        if(lterm >= self.term):
            self.votedFor = None
            self.state = states[0]
            self.term = lterm
            self.resettimer()

            explog = msg['lastIndex']
            logentry = msg['entries']
            if(len(self.transactionlog) >= explog):
                if(explog == 0):
                    self.removebadEntries(logentry, explog)
                    CorrectMsg = {"src": self.id, "dst": self.currentLeader,  "leader": self.currentLeader, "type" : "response", "success" : "true", "loglength" : len(self.transactionlog), "term": self.term}
                    self.commitEntriesReplica(msg['commitlength'])
                    self.send(CorrectMsg)

                elif(self.transactionlog[explog - 1][1] == msg['lastTerm']):
                    #remove bad entries and apply the correcly committed indices on top of them.
                    #print("are values being killed off: " + str(statemachine))
                    self.removebadEntries(logentry, explog)
                    self.commitEntriesReplica(msg['commitlength'])
                    CorrectMsg = {"src": self.id, "dst": self.currentLeader,  "leader": self.currentLeader, "type" : "response", "success" : "true", "loglength" : len(self.transactionlog), "term": self.term}
                    self.send(CorrectMsg)
                else:
                    print("this case failed, term of my last transaction log is different" )
                    self.send(failMsg)
            else:
                print("this case failed, length of my transaction log is:" + str(len(self.transactionlog)))
                self.send(failMsg)
        else:
            print("My current term: " + str(self.term) + " leaders current term: " + str(lterm))
            print("leader's term is not right, did not append entries")
            self.send(failMsg)         


    def commitEntriesReplica(self, commitlength):
        #print("Replica's starting commit length is: " + str(self.committed) + " compared to leaders committed: " + str(commitlength))
        #print("Starting this method the replicas length of log is: " + str(len(self.transactionlog)))
        count = 0
        #print("Before execution, the replicas commitindex is:" + str(self.committed))
        #print("Before execution the length of the state machine is: " + str(len(statemachine)))
        while(self.committed < commitlength):
            self.committed +=1
            key = self.transactionlog[self.committed -1][0][0]
            value = self.transactionlog[self.committed -1][0][1]
            #print("this is key our replica found: " + key)

            #don't think I need this anymore

            try:
                testvalue = statemachine[key]
                statemachine[key] = value
            except:
                statemachine[key] = value

            count += 1     

            #print("the length of replica machines in this loop: " + str(len(statemachine)))
        
        #print("Given a commitlength of: " + str(commitlength) + " this loop created new entries?:" + str(count))    
       # print("currentlength of statemachine " + str(len(statemachine)))    
        #print("current statemachine:" + str( statemachine))     


    def removebadEntries(self, logentry, explog):

        #again where we are vs where we think you are, we take the min of that
        #if where we think you are is less, but it doesn't have the correct term, then you should only take what we have and remove anything afterwards
        #getting the very best index to compare

        currentlog = len(self.transactionlog)
        #where we are vs where we think we are,
        if(currentlog > explog):
            #last comparable log index they share
            lastlogindex =  min(currentlog, len(logentry) + explog) - 1
            #does this make sense?
            logdifference = (lastlogindex - (explog - 1)) - 1
            print("the log difference crafted is this: " + str(logdifference))
            print("the length of the actual log entry is this: " + str(len(logentry)))
            if(self.transactionlog[lastlogindex][1] != logentry[logdifference][1]):
                newlog = self.transactionlog[:explog]
                self.transactionlog = newlog

        meaningfulentries = len(self.transactionlog) - explog
        #print("meaningful entries: " + str(meaningfulentries) + " where the log things we are: " + str(explog))

        #don't want to remove entries that the log already has, and are commited, 
        #because it looks like that fucks with the state machinies because python mutation is amazing.

        #only remove when there are bogus entries that doesn't make sense,

        #if we accepted that at this log position we are the same, then we can stil add.
        #important maybe, but why don't I just append each thing on?
        entries = logentry[meaningfulentries::]
        self.transactionlog.extend(entries)

        #truncate and remove bad entries, and then apply entires that the follower has not yet alraedy seen...    


    def determineResponse(self, msg):
        #include term, and if the leader detects someone with a grater term we must accept it and then behave as a follower,
        #and disregard this section.
        if(self.state == states[2]):
            term = msg["term"]
            if(term > self.term):
                self.state = states[0]
                self.term = term
                self.votedFor = None
                self.currentLeader = BROADCAST
                print("recognized bad term, my new state is: " + self.state)

            else:
                if(msg['success'] == "true"):
                    fresponselen = msg['loglength']
                    follower = msg['src']
                    self.responselen[follower] = fresponselen
                    self.nextIndex[follower] = fresponselen
                    self.determineCommitted(msg)
                
                else:
                    src = msg["src"]
                    item = self.nextIndex[src]
                    print("Replica :" + str(src) + " last Index did not match shifting back:" + str(item))
                    self.nextIndex[src] = item - 1

                    newentries = self.createEntries(src)
                    
                    newterm = self.transactionlog[self.nextIndex[src]][1]
                    
                    newmsg = {"src": self.id, "dst": src,  "leader": self.currentLeader, "type": "appendEntry", "commitlength": self.committed, "entries": newentries, "lastIndex" : self.nextIndex[src], "lastTerm" : newterm, "term": self.term }
                    self.send(newmsg)

    def determineCommitted(self, msg):
        #another time to trigger to commit whatever we have in the log, service the clients faster?
        #respond to put requets, and then getting a ton of get requests, and didn't respond back to clients with oks yet


        #put this in a while loop to do this more efficiently, especially when a new leader comes in.
        #adding the while loop makes it so that it responds to clients better, but there may be duplicate responses,
        #so may want to handle that
        while(self.committed < len(self.transactionlog)):
            totalcommitted = 0
            for k, v in self.responselen.items():
                if(v > self.committed and v > 0):
                    print("Node: " + str(k) + " Length " + str(v))
                    totalcommitted += 1

            if(totalcommitted >= 3):

                #I'll  make this transaction log simpler sorry about this...
                #Right now the log look like => [((key, value, mid, src), term)], creating one really long 3D array
                #Ill make this into a basic tuple once I know how many variables I have set.
                #instead reference the log that we have put in...
                #also need to shorten this since its causing error with messages being too long, need to come up with a way later,
                self.committed +=1
                #print(self.committed - 1)
                key = self.transactionlog[self.committed -1][0][0]
                value = self.transactionlog[self.committed -1][0][1]
                statemachine[key] = value

                src = value = self.transactionlog[self.committed - 1][0][2]
                mid = self.transactionlog[self.committed - 1][0][3]

                print("MSGID and key added: " + mid + " " + key)
                okmessage = {"src": self.id, "dst": src,  "leader": self.currentLeader, "type": "ok", "MID": mid}
                self.send(okmessage)

            else:
                break    


    def doGetRequest(self,msg):
        hdst = msg['src']
        mid = msg['MID']
        leader = msg["leader"]

        if(self.state == states[0] or self.state == states[1]):
            if(leader != self.currentLeader):
                if(self.currentLeader == 'FFFF'):
                    self.msgqueue.append(msg)
                else:
                    redirectmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "redirect", "MID": mid}
                    self.send(redirectmessage)

        else:
            try:
                key = msg['key']
                value = statemachine[key]
                okmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "ok", "MID": mid, "value": value}
                self.send(okmessage)

            except:
                notokmessage = {"src": self.id, "dst": hdst,  "leader": self.currentLeader, "type": "ok", "MID": mid, "value": []}
                self.send(notokmessage)    

    #TODO
    #This again I think only works because of the term condition check so I may need to fix this because it could vote more than
    #once on accident
    def electionProcess(self):
        self.votes = 0
        newterm = self.term + 1
        self.term = newterm
        self.state = states[1]
        #self.leader = "FFFF"
        #for each replica relay the message and the new term number, and tell themt that we want to request a vote for a leader.
        RequestVote = {"src": self.id, "dst": None, "leader": self.currentLeader, "type": "voting", "newterm": newterm, "votedfor" : self.id, "lastIndex": len(self.transactionlog)}
        if(len(self.transactionlog) > 0):
            RequestVote["lastTerm"] = self.transactionlog[-1][1]

        for replica in self.others:
            RequestVote["dst"] = replica
            self.send(RequestVote) 
            #doing this in this loop seems sus...  
            self.votedFor = self.id
            self.votes = 1
            #if we vote for ourselves, then we have a vote

    #make sure to reset voted for after sometime.        
    def voteLeader(self, msg):
        #how to make sure not to vote multiple times, we immediately take their term,
        # so another vote at the same time would have a lower term value and we would immediately deny their request
        term  = msg['newterm']
        BadVote = {"src": self.id, "dst": msg["src"], "leader": self.currentLeader, "type": "vote", "voted?": "false"}
        GoodVote = {"src": self.id, "dst": msg["src"], "leader": self.currentLeader, "type": "vote", "voted?": "true"}

       #if we have already voted for someone, i.e we took their term, then someone coming in for the same term wouldn't get
       # a response 
        if(term > self.term):
            self.state = states[0]
            self.term = term
            self.votedFor = None
            self.resettimer()

            candidatelength = msg["lastIndex"]
            if(candidatelength == 0):
                if(len(self.transactionlog) == candidatelength and self.votedFor == None):
                    self.votedFor = msg['src']
                    GoodVote["term"] = self.term
                    self.send(GoodVote)
                else:
                    BadVote["term"] = self.term
                    self.send(BadVote)    
            else:
                #not exactly like the video so we'll see if this works.
                if(len(self.transactionlog) <= candidatelength):
                    #if their log is at least the length of our log
                    #if their term at that last entry is at least as good as ours, send out a vote.
                    ourlastTerm = self.transactionlog[-1][1]
                    if(msg['lastTerm'] >= ourlastTerm and self.votedFor == None):
                    #if(self.transactionlog[candidatelength -1][1] >= msg['lastTerm'] and self.votedFor == None):
                        self.votedFor = msg['src']
                        GoodVote["term"] = self.term
                        self.send(GoodVote)
                    else:
                        print("this case triggered when we sent a bad vote2")
                        BadVote["term"] = self.term
                        self.send(BadVote)
                else:
                    print("this case triggered when we sent a bad vote1")
                    BadVote["term"] = self.term
                    self.send(BadVote)

        else:
            print("this case triggered when we sent a bad vote3")
            BadVote["term"] = self.term
            self.send(BadVote)

    def processVote(self, msg):
        #just quick error handling for when a message may fail and someone has a greater term it transitions back into follower
        self.resettimer()
        term = msg["term"]
        if(term > self.term):
            self.state = states[0]
            self.term = term
            self.votedFor = None
            self.votes = 0

        else:
            #else the term must be the same, otherwise it would not have voted.
            #print("current amount of votes recieved" + str(self.votes))
            print("Replica: " + self.id + "received a vote")
            if(msg['voted?'] == "true"):
                self.votes += 1


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
